/**
 * Shape class for creating and manipulating vector graphics paths.
 *
 * Shape is the fundamental drawing primitive in ThorVG Canvas Kit. It provides methods for
 * creating paths using moveTo/lineTo/cubicTo commands, as well as convenience methods for
 * common shapes like rectangles and circles. Shapes can be filled with solid colors or
 * gradients, and stroked with customizable line styles.
 *
 * @category Shapes
 *
 * @example
 * Basic triangle
 * ```typescript
 * const shape = new TVG.Shape();
 * shape.moveTo(100, 50)
 *      .lineTo(150, 150)
 *      .lineTo(50, 150)
 *      .close()
 *      .fill(255, 0, 0, 255);
 * canvas.add(shape).render();
 * ```
 *
 * @example
 * Rectangle with rounded corners
 * ```typescript
 * const rect = new TVG.Shape();
 * rect.appendRect(50, 50, 200, 100, { rx: 10, ry: 10 })
 *     .fill(0, 120, 255, 255)
 *     .stroke({ width: 3, color: [0, 0, 0, 255] });
 * ```
 *
 * @example
 * Circle with gradient fill
 * ```typescript
 * const circle = new TVG.Shape();
 * const gradient = new TVG.RadialGradient(150, 150, 50);
 * gradient.addStop(0, [255, 255, 255, 255])
 *         .addStop(1, [0, 100, 255, 255]);
 *
 * circle.appendCircle(150, 150, 50)
 *       .fill(gradient);
 * ```
 *
 * @example
 * Complex path with bezier curves
 * ```typescript
 * const shape = new TVG.Shape();
 * shape.moveTo(50, 100)
 *      .cubicTo(50, 50, 150, 50, 150, 100)
 *      .cubicTo(150, 150, 50, 150, 50, 100)
 *      .close()
 *      .fill(255, 100, 0, 255);
 * ```
 */

import { Paint } from './Paint';
import { Fill } from '../fill/Fill';
import { getModule } from '../core/Module';
import { shapeRegistry } from '../core/Registry';
import type { StrokeCapType, StrokeJoinType } from '../constants';
import { StrokeCap, StrokeJoin } from '../constants';
import { checkResult } from '../core/errors';

/**
 * Options for creating rectangles with rounded corners.
 *
 * @category Shapes
 */
export interface RectOptions {
  /** Horizontal corner radius. Default: 0 */
  rx?: number;
  /** Vertical corner radius. Default: 0 */
  ry?: number;
  /** Path direction. true = clockwise, false = counter-clockwise. Default: true */
  clockwise?: boolean;
}

/**
 * Comprehensive stroke styling options.
 *
 * @category Shapes
 */
export interface StrokeOptions {
  /** Stroke width in pixels */
  width?: number;
  /** Stroke color as [r, g, b, a] with values 0-255. Alpha is optional, defaults to 255. */
  color?: readonly [number, number, number, number?];
  /** Gradient fill for the stroke */
  gradient?: Fill;
  /** Line cap style: 'butt', 'round', or 'square'. Default: 'butt' */
  cap?: StrokeCapType;
  /** Line join style: 'miter', 'round', or 'bevel'. Default: 'miter' */
  join?: StrokeJoinType;
  /** Miter limit for 'miter' joins. Default: 4 */
  miterLimit?: number;
}

/**
 * Shape class for creating and manipulating vector graphics paths.
 *
 * Extends {@link Paint} to inherit transformation and opacity methods.
 *
 * @category Shapes
 *
 * @example
 * ```typescript
 * // Drawing basic shapes
 * const shape = new TVG.Shape();
 *
 * // Rectangle with rounded corners
 * shape.appendRect(50, 50, 200, 100, 10)
 *      .fill(255, 100, 100, 255)
 *      .stroke(50, 50, 50, 255, 2);
 *
 * canvas.add(shape);
 * ```
 *
 * @example
 * ```typescript
 * // Drawing paths with gradients
 * const shape = new TVG.Shape();
 * shape.moveTo(100, 100)
 *      .lineTo(200, 150)
 *      .lineTo(150, 250)
 *      .close();
 *
 * const gradient = new TVG.LinearGradient(100, 100, 200, 250);
 * gradient.addStop(0, [255, 0, 0, 255])
 *         .addStop(1, [0, 0, 255, 255]);
 *
 * shape.fillGradient(gradient);
 * canvas.add(shape);
 * ```
 *
 * @example
 * ```typescript
 * // Complex path with transformations
 * const shape = new TVG.Shape();
 * shape.appendCircle(0, 0, 50)
 *      .fill(100, 200, 255, 255)
 *      .translate(400, 300)
 *      .scale(1.5)
 *      .rotate(45);
 *
 * canvas.add(shape);
 * ```
 */
export class Shape extends Paint {
  constructor() {
    const Module = getModule();
    const ptr = Module._tvg_shape_new();
    super(ptr, shapeRegistry);
  }

  protected _createInstance(ptr: number): Shape {
    // Create shape from existing pointer (for duplicate)
    const shape = Object.create(Shape.prototype) as Shape;
    // Manually initialize the shape with the new pointer
    Object.setPrototypeOf(shape, Shape.prototype);
    shape.ptr = ptr;
    return shape;
  }

  /**
   * Moves the path cursor to a new point without drawing.
   *
   * This starts a new subpath at the specified coordinates. Subsequent drawing commands
   * will start from this point.
   *
   * @param x - X coordinate
   * @param y - Y coordinate
   * @returns The Shape instance for method chaining
   *
   * @example
   * ```typescript
   * shape.moveTo(100, 100)
   *      .lineTo(200, 200);
   * ```
   */
  public moveTo(x: number, y: number): this {
    const Module = getModule();
    const result = Module._tvg_shape_move_to(this.ptr, x, y);
    checkResult(result, 'moveTo');
    return this;
  }

  /**
   * Draws a straight line from the current point to the specified coordinates.
   *
   * @param x - End X coordinate
   * @param y - End Y coordinate
   * @returns The Shape instance for method chaining
   *
   * @example
   * Draw a triangle
   * ```typescript
   * shape.moveTo(100, 50)
   *      .lineTo(150, 150)
   *      .lineTo(50, 150)
   *      .close();
   * ```
   */
  public lineTo(x: number, y: number): this {
    const Module = getModule();
    const result = Module._tvg_shape_line_to(this.ptr, x, y);
    checkResult(result, 'lineTo');
    return this;
  }

  /**
   * Draws a cubic BÃ©zier curve from the current point to (x, y).
   *
   * @param cx1 - X coordinate of first control point
   * @param cy1 - Y coordinate of first control point
   * @param cx2 - X coordinate of second control point
   * @param cy2 - Y coordinate of second control point
   * @param x - End X coordinate
   * @param y - End Y coordinate
   * @returns The Shape instance for method chaining
   *
   * @example
   * Draw a smooth curve
   * ```typescript
   * shape.moveTo(50, 100)
   *      .cubicTo(50, 50, 150, 50, 150, 100);
   * ```
   */
  public cubicTo(
    cx1: number,
    cy1: number,
    cx2: number,
    cy2: number,
    x: number,
    y: number
  ): this {
    const Module = getModule();
    const result = Module._tvg_shape_cubic_to(this.ptr, cx1, cy1, cx2, cy2, x, y);
    checkResult(result, 'cubicTo');
    return this;
  }

  /**
   * Closes the current subpath by drawing a straight line back to the starting point.
   *
   * @returns The Shape instance for method chaining
   *
   * @example
   * ```typescript
   * shape.moveTo(100, 50)
   *      .lineTo(150, 150)
   *      .lineTo(50, 150)
   *      .close(); // Completes the triangle
   * ```
   */
  public close(): this {
    const Module = getModule();
    const result = Module._tvg_shape_close(this.ptr);
    checkResult(result, 'close');
    return this;
  }

  /**
   * Appends a rectangle path to the shape.
   *
   * Creates a rectangular path with optional rounded corners. Multiple rectangles
   * can be added to the same shape.
   *
   * @param x - X coordinate of the top-left corner
   * @param y - Y coordinate of the top-left corner
   * @param w - Width of the rectangle
   * @param h - Height of the rectangle
   * @param options - Optional corner rounding and path direction
   * @returns The Shape instance for method chaining
   *
   * @example
   * Simple rectangle
   * ```typescript
   * shape.appendRect(50, 50, 200, 100);
   * ```
   *
   * @example
   * Rounded rectangle
   * ```typescript
   * shape.appendRect(50, 50, 200, 100, { rx: 10, ry: 10 });
   * ```
   */
  public appendRect(
    x: number,
    y: number,
    w: number,
    h: number,
    options: RectOptions = {}
  ): this {
    const Module = getModule();
    const { rx = 0, ry = 0, clockwise = true } = options;
    const result = Module._tvg_shape_append_rect(
      this.ptr,
      x,
      y,
      w,
      h,
      rx,
      ry,
      clockwise ? 1 : 0
    );
    checkResult(result, 'appendRect');
    return this;
  }

  /**
   * Appends a circle or ellipse path to the shape.
   *
   * Creates a circular or elliptical path. If only one radius is provided,
   * creates a perfect circle. If two radii are provided, creates an ellipse.
   *
   * @param cx - X coordinate of the center
   * @param cy - Y coordinate of the center
   * @param rx - Horizontal radius
   * @param ry - Vertical radius (defaults to rx for perfect circle)
   * @param clockwise - Path direction. Default: true
   * @returns The Shape instance for method chaining
   *
   * @example
   * Perfect circle
   * ```typescript
   * shape.appendCircle(150, 150, 50)
   *      .fill(255, 0, 0, 255);
   * ```
   *
   * @example
   * Ellipse
   * ```typescript
   * shape.appendCircle(150, 150, 80, 50)
   *      .fill(0, 100, 255, 255);
   * ```
   */
  public appendCircle(
    cx: number,
    cy: number,
    rx: number,
    ry: number = rx,
    clockwise: boolean = true
  ): this {
    const Module = getModule();
    const result = Module._tvg_shape_append_circle(this.ptr, cx, cy, rx, ry, clockwise ? 1 : 0);
    checkResult(result, 'appendCircle');
    return this;
  }

  /**
   * Sets the fill for the shape with a gradient.
   *
   * @param gradient - LinearGradient or RadialGradient to use as fill
   * @returns The Shape instance for method chaining
   */
  public fill(gradient: Fill): this;

  /**
   * Sets the fill for the shape with a solid color.
   *
   * @param r - Red component (0-255)
   * @param g - Green component (0-255)
   * @param b - Blue component (0-255)
   * @param a - Alpha component (0-255). Default: 255 (opaque)
   * @returns The Shape instance for method chaining
   */
  public fill(r: number, g: number, b: number, a?: number): this;

  /**
   * Sets the fill for the shape with either a solid color or gradient.
   *
   * This method supports two calling patterns:
   * 1. Solid color: `fill(r, g, b, a?)`
   * 2. Gradient: `fill(gradient)`
   *
   * @example
   * Solid color fill
   * ```typescript
   * shape.fill(255, 0, 0, 255); // Red
   * shape.fill(0, 255, 0);      // Green (alpha defaults to 255)
   * ```
   *
   * @example
   * Gradient fill
   * ```typescript
   * const gradient = new TVG.LinearGradient(0, 0, 200, 0);
   * gradient.addStop(0, [255, 0, 0, 255])
   *         .addStop(1, [0, 0, 255, 255]);
   * shape.fill(gradient);
   * ```
   */
  public fill(
    gradientOrR: Fill | number,
    g?: number,
    b?: number,
    a: number = 255
  ): this {
    const Module = getModule();

    if (gradientOrR instanceof Fill) {
      // Gradient fill - apply pending stops before setting
      gradientOrR['_applyStops']();
      const result = Module._tvg_shape_set_gradient(this.ptr, gradientOrR.ptr);
      checkResult(result, 'fill (gradient)');
    } else if (typeof gradientOrR === 'number' && g !== undefined && b !== undefined) {
      // RGB or RGBA color
      const result = Module._tvg_shape_set_fill_color(this.ptr, gradientOrR, g, b, a);
      checkResult(result, 'fill (color)');
    } else {
      throw new TypeError('Invalid fill arguments');
    }
    return this;
  }

  /**
   * Sets the stroke width for the shape.
   *
   * @param width - Stroke width in pixels
   * @returns The Shape instance for method chaining
   */
  public stroke(width: number): this;

  /**
   * Sets comprehensive stroke styling options for the shape.
   *
   * @param options - Stroke configuration including width, color, gradient, caps, joins, and miter limit
   * @returns The Shape instance for method chaining
   */
  public stroke(options: StrokeOptions): this;

  /**
   * Sets the stroke styling for the shape.
   *
   * This method supports two calling patterns:
   * 1. Simple width: `stroke(width)`
   * 2. Full options: `stroke({ width, color, gradient, cap, join, miterLimit })`
   *
   * @example
   * Simple stroke
   * ```typescript
   * shape.appendCircle(150, 150, 50)
   *      .stroke(3);
   * ```
   *
   * @example
   * Stroke with color and caps
   * ```typescript
   * shape.appendRect(50, 50, 200, 100)
   *      .stroke({
   *        width: 5,
   *        color: [0, 0, 0, 255],
   *        cap: 'round',
   *        join: 'round'
   *      });
   * ```
   *
   * @example
   * Stroke with gradient
   * ```typescript
   * const gradient = new TVG.LinearGradient(0, 0, 200, 0);
   * gradient.addStop(0, [255, 0, 0, 255])
   *         .addStop(1, [0, 0, 255, 255]);
   *
   * shape.appendCircle(150, 150, 50)
   *      .stroke({
   *        width: 10,
   *        gradient: gradient,
   *        cap: 'round'
   *      });
   * ```
   */
  public stroke(widthOrOptions: number | StrokeOptions): this {
    const Module = getModule();

    if (typeof widthOrOptions === 'number') {
      // Just width
      const result = Module._tvg_shape_set_stroke_width(this.ptr, widthOrOptions);
      checkResult(result, 'stroke (width)');
    } else {
      const { width, color, cap, join, gradient, miterLimit } = widthOrOptions;

      if (width !== undefined) {
        const result = Module._tvg_shape_set_stroke_width(this.ptr, width);
        checkResult(result, 'stroke (width)');
      }
      if (color) {
        const [r, g, b, a = 255] = color;
        const result = Module._tvg_shape_set_stroke_color(this.ptr, r, g, b, a);
        checkResult(result, 'stroke (color)');
      }
      if (gradient) {
        // Apply pending stops before setting stroke gradient
        gradient['_applyStops']();
        const result = Module._tvg_shape_set_stroke_gradient(this.ptr, gradient.ptr);
        checkResult(result, 'stroke (gradient)');
      }
      if (cap) {
        const capMap: Record<StrokeCapType, number> = {
          butt: StrokeCap.Butt,
          round: StrokeCap.Round,
          square: StrokeCap.Square,
        };
        const result = Module._tvg_shape_set_stroke_cap(this.ptr, capMap[cap]);
        checkResult(result, 'stroke (cap)');
      }
      if (join) {
        const joinMap: Record<StrokeJoinType, number> = {
          miter: StrokeJoin.Miter,
          round: StrokeJoin.Round,
          bevel: StrokeJoin.Bevel,
        };
        const result = Module._tvg_shape_set_stroke_join(this.ptr, joinMap[join]);
        checkResult(result, 'stroke (join)');
      }
      if (miterLimit !== undefined) {
        const result = Module._tvg_shape_set_stroke_miterlimit(this.ptr, miterLimit);
        checkResult(result, 'stroke (miterLimit)');
      }
    }
    return this;
  }
}
